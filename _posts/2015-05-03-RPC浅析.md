---
layout: post
title: "RPC浅析"
---

# RPC浅析

## Protobuf简介

### 自描述消息
生产者：产生消息，填充内容，并序列化保存
消费者：读取数据，反序列化得到消息，使用消息

目的：解除这种耦合，让消费者能动态的适应消息格式的变换。

生产者把定义消息格式的.proto文件和消息作为一个完整的消息序列化保存，完整保存的消息我称之为Wrapper message，原来的消息称之为payload message。
消费者把wrapper message反序列化，先得到payload message的消息类型，然后根据类型信息得到payload message，最后通过反射机制来使用该消息。

message SelfDescribingMessage {
  // Set of .proto files which define the type.
  required FileDescriptorSet proto_files = 1;

  // Name of the message type.  Must be defined by one of the files in
  // proto_files.
  required string type_name = 2;

  // The message data.
  required bytes message_data = 3;
}

Todo

### Reflection
- [一种自动反射消息类型的 Google Protobuf 网络传输方案](http://blog.csdn.net/solstice/article/details/6300108)

### 动态自描述消息

### 参考资料
- [Protobuf](https://github.com/google/protobuf)
- [玩转Protobuf](http://www.searchtb.com/2012/09/protocol-buffers.html)
- [Self-describing Messages](https://developers.google.com/protocol-buffers/docs/techniques?hl=zh-CN#self-description)

## RPC

- [使用google protobuf RPC实现echo service](http://www.codedump.info/?p=169)
- [基于protobuf的RPC实现](http://codemacro.com/2014/08/31/protobuf-rpc/)
- [RPC框架系列——Protocol Buffers](http://jeoygin.org/2011/09/rpc-framework-protocol-buffers.html)

- [Poppy]()
- [GDT RPC]()

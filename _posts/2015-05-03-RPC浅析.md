---
layout: post
title: "RPC浅析"
---

# RPC浅析

## Protobuf简介

### 自描述消息

生产者：产生消息，填充内容，并序列化保存

消费者：读取数据，反序列化得到消息，使用消息

目的：解除这种耦合，让消费者能动态的适应消息格式的变换。

生产者把定义消息格式的.proto文件和消息作为一个完整的消息序列化保存，完整保存的消息我称之为Wrapper message，原来的消息称之为payload message。

消费者把wrapper message反序列化，先得到payload message的消息类型，然后根据类型信息得到payload message，最后通过反射机制来使用该消息。

	message SelfDescribingMessage {
  	// Set of .proto files which define the type.
  	required FileDescriptorSet proto_files = 1;

  	// Name of the message type.  Must be defined by one of the files in
  	// proto_files.
  	required string type_name = 2;

  	// The message data.
  	required bytes message_data = 3;
	}

@Todo

### Reflection
- [一种自动反射消息类型的 Google Protobuf 网络传输方案](http://blog.csdn.net/solstice/article/details/6300108)

### 动态自描述消息

### 参考资料
- [Protobuf](https://github.com/google/protobuf)
- [玩转Protobuf](http://www.searchtb.com/2012/09/protocol-buffers.html)
- [Self-describing Messages](https://developers.google.com/protocol-buffers/docs/techniques?hl=zh-CN#self-description)

## RPC

- [使用google protobuf RPC实现echo service](http://www.codedump.info/?p=169)
- [基于protobuf的RPC实现](http://codemacro.com/2014/08/31/protobuf-rpc/)
- [RPC框架系列——Protocol Buffers](http://jeoygin.org/2011/09/rpc-framework-protocol-buffers.html)

- [Poppy]()

### GDT RPC代码解析

**system/io_frame/net_options.h**

  setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &buffer_size, static_cast<socklen_t>(sizeof(buffer_size)))
  setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &buffer_size, static_cast<socklen_t>(sizeof(buffer_size)))

[What are SO_SNDBUF and SO_RECVBUF](http://stackoverflow.com/questions/4257410/what-are-so-sndbuf-and-so-recvbuf)

**echo_service**

echo_service.proto:

  service EchoService {
    option (gdt.qzone_protocol_version) = 1;
    rpc Echo(EchoRequest) returns (EchoResponse) {
      option (gdt.qzone_protocol_cmd) = 10;
    }
    rpc FormTest(FormTestMessage) returns(FormTestMessage);
  }


protoc编译后：

  class EchoService : public ::google::protobuf::Service {
   protected:
    // This class should be treated as an abstract interface.
    inline EchoService() {};
   public:
    virtual ~EchoService();

    typedef EchoService_Stub Stub;

    static const ::google::protobuf::ServiceDescriptor* descriptor();
    // 下面两个是虚函数,需要在子类实现
    virtual void Echo(::google::protobuf::RpcController* controller,
                         const ::gdt::rpc_examples::EchoRequest* request,
                         ::gdt::rpc_examples::EchoResponse* response,
                         ::google::protobuf::Closure* done);
    virtual void FormTest(::google::protobuf::RpcController* controller,
                         const ::gdt::rpc_examples::FormTestMessage* request,
                         ::gdt::rpc_examples::FormTestMessage* response,
                         ::google::protobuf::Closure* done);

    // implements Service ----------------------------------------------

    const ::google::protobuf::ServiceDescriptor* GetDescriptor();
    void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                    ::google::protobuf::RpcController* controller,
                    const ::google::protobuf::Message* request,
                    ::google::protobuf::Message* response,
                    ::google::protobuf::Closure* done);
    const ::google::protobuf::Message& GetRequestPrototype(
      const ::google::protobuf::MethodDescriptor* method) const;
    const ::google::protobuf::Message& GetResponsePrototype(
      const ::google::protobuf::MethodDescriptor* method) const;

   private:
    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(EchoService);
  };

  class EchoService_Stub : public EchoService {
   public:
    EchoService_Stub(::google::protobuf::RpcChannel* channel);
    EchoService_Stub(::google::protobuf::RpcChannel* channel,
                     ::google::protobuf::Service::ChannelOwnership ownership);
    ~EchoService_Stub();

    inline ::google::protobuf::RpcChannel* channel() { return channel_; }

    // implements EchoService ------------------------------------------

    void Echo(::google::protobuf::RpcController* controller,
                         const ::gdt::rpc_examples::EchoRequest* request,
                         ::gdt::rpc_examples::EchoResponse* response,
                         ::google::protobuf::Closure* done);
    void FormTest(::google::protobuf::RpcController* controller,
                         const ::gdt::rpc_examples::FormTestMessage* request,
                         ::gdt::rpc_examples::FormTestMessage* response,
                         ::google::protobuf::Closure* done);
   private:
    ::google::protobuf::RpcChannel* channel_;
    bool owns_channel_;
    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(EchoService_Stub);
  };

  // 客户端实际调用的是RpcChannel的CallMethod
  void EchoService_Stub::Echo(::google::protobuf::RpcController* controller,
                                const ::gdt::rpc_examples::EchoRequest* request,
                                ::gdt::rpc_examples::EchoResponse* response,
                                ::google::protobuf::Closure* done) {
    channel_->CallMethod(descriptor()->method(0),
                         controller, request, response, done);
  }
  void EchoService_Stub::FormTest(::google::protobuf::RpcController* controller,
                                const ::gdt::rpc_examples::FormTestMessage* request,
                                ::gdt::rpc_examples::FormTestMessage* response,
                                ::google::protobuf::Closure* done) {
    channel_->CallMethod(descriptor()->method(1),
                         controller, request, response, done);
  }


**rpc/rpc_channel**
RpcChannelInterface : public ::google::protobuf::RpcChannel

void CallMethod(
      const google::protobuf::MethodDescriptor* method,
      google::protobuf::RpcController* controller,
      const google::protobuf::Message* request,
      google::protobuf::Message* response,
      google::protobuf::Closure* done);

发送请求的背后,最后调用的其实是RpcChannel的CallMethod函数.所以,要实现RpcChannel类,最关键的就是要实现这个函数,在这个函数中完成发送请求的事务.

明天尝试一下，自己写好proto后，用protoc编译后，输出是什么样子的？

rpc_channel.h 里面是空的，没啥东西

**rpc/rpc_controller**
rpc_controller是一个rpc请求过程中的信息。

class RpcController : public google::protobuf::RpcController

主要保存下面这些信息：

  int error_code_;
  std::string reason_;
  int timeout_;
  SocketAddressStorage remote_address_;
  int64_t timestamp_;
  bool in_use_;
  kDefaultTimeout = 2000ms;

**rpc/load_balance**
LoadBalancer是一个单例


<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>VC维的来龙去脉</title>
  <meta name="description" content="VC维的来龙去脉">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/2015/03/07/VC%E7%BB%B4%E7%9A%84%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89.html">
  <link rel="alternate" type="application/rss+xml" title="100的技术博客" href="http://yourdomain.com/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">100的技术博客</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">VC维的来龙去脉</h1>
    <p class="post-meta">Mar 7, 2015</p>
  </header>

  <article class="post-content">
    <h1 id="vc">VC维的来龙去脉</h1>

<h4 id="author-vincentyaotencentcom">author: vincentyao@tencent.com</h4>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<p><strong>目录：</strong></p>

<ul>
  <li>说说历史</li>
  <li>Hoeffding不等式</li>
  <li>Connection to Learning</li>
  <li>学习可行的两个核心条件</li>
  <li>Effective Number of Hypotheses</li>
  <li>Growth Function</li>
  <li>Break Point与Shatter</li>
  <li>VC Bound</li>
  <li>VC dimension</li>
  <li>深度学习与VC维</li>
  <li>Next</li>
</ul>

<h2 id="section">说说历史</h2>

<p>1943年，模拟神经网络由麦卡洛可（McCulloch）和皮茨（Pitts)提出，他们分析了理想化的人工神经元网络，并且指出了它们进行简单逻辑运算的机制。</p>

<p>1957年，康奈尔大学的实验心理学家弗兰克·罗森布拉特(Rosenblatt)在一台IBM-704计算机上模拟实现了一种他发明的叫作”感知机”（Perceptron）的神经网络模型。神经网络与支持向量机都源自于感知机（Perceptron）。</p>

<p>1962年，罗森布拉特著作：《神经动力学原理：感知机和大脑机制的理论》（Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms）。</p>

<p>1969年，明斯基和麻省理工学院的另一位教授佩普特合作著作：《感知机：计算几何学》（Perceptrons: An Introduction to Computational Geometry)。在书中，明斯基和佩普特证明单层神经网络不能解决XOR（异或）问题。</p>

<p>1971年，V. Vapnik and A. Chervonenkis在论文”On the uniform convergence of relative frequencies of events to their probabilities”中提出<strong>VC维</strong>的概念。</p>

<p>1974年，V. Vapnik提出了结构风险最小化原则。</p>

<p>1974年，沃波斯（Werbos）的博士论文证明了在神经网络多加一层，并且利用“后向传播”（Back-propagation）学习方法，可以解决XOR问题。那时正是神经网络研究的低谷，文章不合时宜。</p>

<p>1982年，在加州理工担任生物物理教授的霍普菲尔德，提出了一种新的神经网络，可以解决一大类模式识别问题，还可以给出一类组合优化问题的近似解。这种神经网络模型后被称为霍普菲尔德网络。</p>

<p>1986年，Rummelhart与McClelland发明了神经网络的学习算法Back Propagation。</p>

<p>1992年，Vapnik等人提出了支持向量机(support vector machine)。神经网络是多层的非线性模型，支持向量机利用核技巧把非线性问题转换成线性问题。</p>

<p>1992\~2005年，SVM与Neural network之争，但被互联网风潮掩盖住了。</p>

<p>2006年，Hinton提出神经网络的Deep Learning算法。Deep Learning假设神经网络是多层的，首先用Restricted Boltzmann Machine（非监督学习）学习网络的结构，然后再通过Back Propagation（监督学习）学习网络的权值。</p>

<h2 id="hoeffding">Hoeffding不等式</h2>

<p>Hoeffding不等式是关于一组随机变量均值的概率不等式。
如果\(X_1,X_2,\cdots,X_n\)为一组独立同分布的参数为p的伯努利分布随机变量。定义这组随机变量的均值为：</p>

<script type="math/tex; mode=display">\bar X=\frac{X_1+X_2+\cdots+X_n}{n}</script>

<p>对于任意\(\delta&gt;0\), Hoeffding不等式可以表示为</p>

<script type="math/tex; mode=display">P(|\bar X - E(\bar X)| \geq \delta) \leq \exp(-2\delta^2n^2)</script>

<p>更多请参考:<a href="http://science.scileaf.com/library/2461">Hoeffding不等式</a>，<a href="http://zh.wikipedia.org/zh-cn/集中不等式">集中不等式</a></p>

<p><strong>case示例</strong>：</p>

<p>在统计推断中，我们可以利用样本的统计量(statistic)来推断总体的参数(parameter)，譬如使用样本均值来估计总体期望。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/bin_sample.png" alt="" /></p>

<p>直觉上，如果我们有更多的样本(抽出更多的球)，则样本期望\(\nu\)应该越来越接近总体期望\(\mu\)。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/bin_sample_hoeffding.png" alt="" /></p>

<h2 id="connection-to-learning">Connection to Learning</h2>
<p>机器学习中的概念定义：
f 表示理想的方案，g 表示我们求解的用来预测的假设。
H 是假设空间。
通过算法A，在假设空间H中，根据样本集D，选择最好的假设作为g。
选择标准是 g 近似于 f。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/setup_of_the_learning_problem_add_components.png" alt="" /></p>

<p>拿<a href="http://zh.wikipedia.org/zh/感知器">perceptron</a>来举例。</p>

<p>感知机（perceptron）是一个线性分类器(linear classifiers）。
线性分类器的几何表示：直线、平面、超平面。</p>

<p>perceptron的假设空间，用公式描述，如下所示：</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/perceptron_formula.jpg" alt="" /></p>

<p>感知器的优化目标如下式所示，w_g就是我们要求的最好的假设。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/perceptron_optim.jpg" alt="" /></p>

<p>设定两个变量，如下图所示。(图中 f(x)表示理想目标函数，h(x)是我们预估得到的某一个目标函数)</p>

<p>Eout(h)，可以理解为在理想情况下(已知f)，总体(out-of-sample)的损失(这里是0-1 loss)的期望，称作expected loss。</p>

<p>Ein(h)，可以理解为在训练样本上(in-of-sample)，损失的期望，称作expirical loss。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/learning_hoeffding.png" alt="" /></p>

<p>当样本量N足够大，且样本是独立同分布的，类比于上面”抽球”的例子，可以通过样本集上的expirical loss Ein(h)推测expected loss Eout(h)。基于hoeffding不等式，我们得到下面式子：</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/learning_hoeffding2.png" alt="" /></p>

<p>根据hoeffding不等式，我们可以推断N足够大时，expected loss和expirical loss将非常接近。</p>

<p>注意在上面推导中，我们是针对某一个特定的解h(x)。在我们的假设空间H中，往往有很多个假设函数(甚至于无穷多个)，这里我们先假定H中M个假设函数。</p>

<p>那么对于整个假设空间，也就是这M个假设函数，可以推导出下面不等式：</p>

<p><script type="math/tex">P(|E_{in}(h_1)-E_{out}(h_1)|>\epsilon  \cup |E_{in}(h_2)-E_{out}(h_2)| > \epsilon   ... |E_{in}(h_m)-E_{out}(h_m)|>\epsilon)</script>
<script type="math/tex">\leq P(|E_{in}(h_1)-E_{out}(h_1)|>\epsilon) + P(|E_{in}(h_2)-E_{out}(h_2)|>\epsilon) + ... + P(|E_{in}(h_m)-E_{out}(h_m)|>\epsilon)</script>
<script type="math/tex">\leq 2M\exp(-2 \epsilon^2 N)</script></p>

<p>注意上面不等式的bound值与 “样本数N和假设数M” 密切相关。</p>

<h2 id="section-1">学习可行的两个核心条件</h2>

<p>在往下继续推导前，先看一下<strong>什么情况下Learning是可行的</strong>？</p>

<ol>
  <li>如果假设空间H的size M是有限的，N足够大，那么对假设空间中任意一个g，Eout(g)约等于Ein(g)；</li>
  <li>利用算法A从假设空间中，挑选出一个g，使得Ein(g)=0，那么probably approximately correct而言，Eout(g)也接近为0；</li>
</ol>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/two_central_questions.png" alt="" /></p>

<p>上面这两个核心条件，也正好对应着test和train这两个过程。我们更多在关心，如何基于模型的假设空间，利用最优化算法，找到Ein最小的解g。但容易忽视test这个过程，如果让学习可行，不仅仅是要在训练集表现好，在真实环境里也要表现好。</p>

<p>从上述推导出来的不等式，我们看到假设数M 在这两个核心条件中有着重要作用。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/trade_off_on_M.png" alt="" /></p>

<p>假设空间H的大小M很关键。M太小，第二项不能满足，M太大，第一项不能满足。</p>

<p>那么有一个直观的思路，能否找到一个有限的因子m_H来替代不等式bound中的M。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/finite_quantity.png" alt="" /></p>

<p>虽说假设空间很大，上述推导里，我们用到了P(h1 or h2 … hm) &lt;= P(h1) + P(h2) + … + P(hm)。但事实上，多个h之间并不是完全独立的，他们是有很大的重叠的。</p>

<p>譬如说，我们的算法要在平面上(二维空间)挑选一条直线方程作为g，用来划分一个点x1。假设空间H是所有的直线，这个size M是无限多的。但是实际上可以将这些直线分为两类，一类是把x1判断为正例的，另一类是把x1判断为负例的。如下图所示：</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/1point2lines.png" alt="" /></p>

<p>那如果在平面上有两个数据点x1,x2，这样的话，假设空间H中的无数条直线可以分为4类。那依次类推，有3个数据点，H中最多有8类直线，4个数据点，H中最多有14类直线(注意：为什么不是16类直线)。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/4points14lines.png" alt="" /></p>

<p>从上面，我们可以得到一个结论，假设空间size M很大，但在样本集D上，有效的假设函数size是有限的，下面我们将继续推导这个值m_H。</p>

<h2 id="effective-number-of-hypotheses">Effective Number of Hypotheses</h2>

<p>从H中任意选择一个方程h，让这个h对样本集合进行二元分类，输出一个结果向量。例如对4个点进行预测，输出为{1,1,1,0}，这样一个输出向量我们即为一个dichotomies。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/effective_number_of_lines.png" alt="" /></p>

<p>如果有N个样本数据，那么有效的Hypotheses个数：effective(N) = H作用于样本集D”最多”能产生多少不同的dichotomy。那么就可以用effective(N)来替换M。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/finite_effective_n.png" alt="" /></p>

<p>下面是hypotheses与dichotomies的对比：</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/dichotomies.png" alt="" /></p>

<h2 id="growth-function">Growth Function</h2>

<p>H作用于D”最多”能产生多少种不同的idchotomy？这个数量与H有关，跟数据量N也有关。用数学公式可以表达为：</p>

<p>max_H(x1,x2,…,xN)</p>

<p>这个式子又称为”成长函数”。在H确定的情况下，growth function是一个与N相关的函数。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/growth_function.png" alt="" /></p>

<p>下图举了4个例子，分别计算其growth function：</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/growth_function_4case.png" alt="" /></p>

<p>求解出m_H(N)，是不是可以考虑用m_H(N)替换effective(N)? 如下所示：</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/growth_function_replace_m.png" alt="" /></p>

<h2 id="break-pointshatter">Break Point与Shatter</h2>

<p>在进一步推导前，再看两个概念：break point，shatter。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/break_point.png" alt="" /></p>

<p>Shatter的概念：当H作用于N个input的样本集时，产生的dichotomies数量等于这N个点总的组合数\(2^N\)是，就称：这N个inputs被H给shatter掉了。</p>

<p>要注意到 shatter 的原意是”打碎”，在此指”N个点的所有(碎片般的)可能情形都被H产生了”。所以\( m_H(N)=2^N \)的情形是”shatter”。</p>

<p>对于给定的成长函数m_H(N)，从N=1出发，N慢慢变大，当增大到k时，出现\(m_H(N) &lt; 2^k\)的情形，则我们说k是该成长函数的<strong>break point</strong>。对于任何N &gt; k个inputs而言，H都没有办法再shatter他们了。</p>

<h2 id="vc-bound">VC Bound</h2>
<p>成长函数的上界，设为B(N,k)，意为：maximum possible m_H(N) when break point = k。</p>

<p>通过一定的推导，我们有：B(N,k) ≤ B(N−1,k)+B(N−1,k−1)，再利用数学归纳法，得到：</p>

<script type="math/tex; mode=display">m_H(N) \leq \sum_{i=0}^{k−1}{N \choose i}</script>

<p>这个式子显然是多项式的，最高次幂是 k-1。</p>

<p>所以我们得到结论：如果break point存在（有限的正整数），生长函数m(N) 是多项式的。</p>

<p>H作用于数据量为N的样本集D，方程的数量看上去是无穷的，但真正有效(effective)的方程的数量却是有限的。H当中每一个h作用于D都能算出一个Ein来，一共有m_H(N)个不同的Ein。</p>

<p>OK，到目前为止，关于m_H(N)的推导结束了，回到growth function小节提出的问题，能否用<strong>m_H(N)直接替换M?</strong></p>

<p>既然得到了m(N) 的多项式上界，我们希望对之前的不等式中M 进行替换，用m_H(N)来替换M。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/replace_vc_bound.png" alt="" /></p>

<p>然而直接替换是存在问题的，主要问题是：Ein的可能取值是有限个的，但Eout的可能取值是无限的。可以通过将Eout 替换为验证集(verification set) 的Ein’ 来解决这个问题。
下面是推导过程：</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/vc_bound_step1.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/vc_bound_step2.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/vc_bound_step3.png" alt="" /></p>

<p>最后我们得到下面的VC bound:</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/vc_bound1.png" alt="" /></p>

<h2 id="vc-dimension">VC dimension</h2>

<p>由Vladimir Vapnik与Alexey Chervonenkis提出。 <a href="http://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_theory">Vapnik–Chervonenkis theory</a></p>

<p>一个H的<strong>VC dimension</strong>即为\(d<em>{vc}(H)\)，是这个H最多能够shatter掉的点的数量。如果不管多少个点H都能shatter他们，则\(d</em>{vc}(H)\)=无穷大。</p>

<script type="math/tex; mode=display"> k = d_{vc}(H) + 1 </script>

<p>VC维的大小：与学习算法A无关，与输入变量X的分布也无关，与我们求解的目标函数f 无关。只与模型和假设空间有关。</p>

<p>前面我们已经分析了，对于2维的perceptron，它不能shatter 4个样本点，所以它的VC维是3。那这个时候，我们可以看下，2维的perceptron，如果样本集是线性可分的，perceptron learning algorithm可以在假设空间里找到一条直线，使Ein(g)=0；另外由于VC维=3，当N足够大的时候，可以推断出：Eout(g)约等于Ein(g)。所以得到Eout(g)约等于0，这也就证明了2维感知器是可学习的。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/pla_revised.png" alt="" /></p>

<p>可以更进一步推导出，感知器的dvc = d+1，d是X的维度。推导这里不写了。</p>

<p>总结回顾一下，要想让机器学到东西，并且学得好，有2个条件：</p>

<ul>
  <li>1.1 H的d_vc是有限的，这样VC bound才存在。(good H)</li>
  <li>1.2 N足够大(对于特定的d_vc而言)，这样才能保证vc bound不等式的bound不会太大。(good D)</li>
  <li>2 算法A有办法再H中顺利的挑选一个使得Ein最小的g。(good A)</li>
</ul>

<p>VC维反映了假设H 的强大程度(powerfulness)，VC 维越大，H也越强，因为它可以打散(shatter)更多的点。</p>

<p>定义模型自由度是，模型当中可以自由变动的参数的个数，即我们的机器需要通过学习来决定模型参数的个数。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/degree_of_freedom.png" alt="" /></p>

<p>一个实践规律：VC 维与假设参数w 的自由变量数目大约相等。dVC = #free parameters。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/vc_practical_rule.png" alt="" /></p>

<p>回到最开始提出的两个核心问题，尝试用VC维来解释：</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/m_and_d_vc.png" alt="" /></p>

<p>”模型复杂度“ 的惩罚(penalty)，基本表达了模型越复杂（VC维大），Eout 可能距离Ein 越远。如下图所示，随着d_vc的上升，E_in不断降低，而模型复杂度不断上升。</p>

<p>他们的上升与下降的速度在每个阶段都是不同的，因此我们能够寻找一个二者兼顾的，比较合适的d_vc，用来决定应该使用多复杂的模型。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/vc_power.png" alt="" /></p>

<p>模型较复杂时(d_vc 较大)，需要更多的训练数据。 理论上，数据规模N 约等于 10000*d_vc（称为采样复杂性，sample complexity）；然而，实际经验是，只需要 N = 10*d_vc。
造成理论值与实际值之差如此之大的最大原因是，VC Bound 过于宽松了，我们得到的是一个比实际大得多的上界。</p>

<p><img src="https://raw.githubusercontent.com/zzbased/zzbased.github.com/master/other/VC理论/n_practical_rule.png" alt="" /></p>

<h2 id="vc-1">深度学习与VC维</h2>

<p>在以前，多层神经网络的VC dimension很高，但是用于训练的样本很少，所以在out of sample的表现不是很好。</p>

<p>一个三层神经网络：输入节点为1000个，隐藏层为1000个，输出为1个。参数个数为：1000*1000+1000 = 100w。那么它的VC维大约等于100w。</p>

<p>但现在为什么深度学习好用了，因为大数据，训练数据量越来越大，然后随着机器计算水平的提升，所以深度学习得到一个流行。所以RBM，sparse coding等算法也得到了使用。</p>

<p>另外卷积神经网络，为什么使用效果很好，因为它通过局部感受野和权值共享这两个利器，减少了参数个数。譬如2012年的AlexNet，8层网络，参数个数只有60M；而2014年的<a href="http://www.cs.unc.edu/~wliu/papers/GoogLeNet.pdf">GoogLeNet</a>，22层网络，参数个数只有7M。</p>

<p>更多细节请参考下面链接：</p>

<ul>
  <li>
    <p><a href="http://ttic.uchicago.edu/~tewari/lectures/lecture12.pdf">VC Dimension of Multilayer Neural Networks</a>，该文章给出了多层神经网络的VC bound的证明。</p>
  </li>
  <li>
    <p><a href="http://www.kdnuggets.com/2014/02/exclusive-yann-lecun-deep-learning-facebook-ai-lab.html">Lecun: What is the relationship between Deep Learning and Support Vector Machines / Statistical Learning Theory? </a></p>

    <p>Vapnik really believes in his bounds. He worried that neural nets didn’t have similarly good ways to do capacity control (although neural nets do have generalization bounds, since they have finite VC dimension).</p>

    <p>Lecun’s counter argument was that the ability to do capacity control was somewhat secondary to the ability to compute highly complex function with a limited amount of computation.</p>
  </li>
  <li>
    <p><a href="http://www.cs.nyu.edu/~yann/talks/lecun-ranzato-icml2013.pdf">Deep Learning Tutorial </a></p>
  </li>
</ul>

<h2 id="next">Next</h2>

<p>上面仔细分析了VC维的来龙去脉，讲述了VC维在机器学习理论中的指导意义。</p>

<p>下一篇，我们讲述：loss function的问题。</p>

<h2 id="section-2">参考资料</h2>
<ul>
  <li><a href="http://www.autonlab.org/tutorials/vcdim.html">VC dimension Tutorial Slides by Andrew Moore</a></li>
  <li>PRML</li>
  <li>机器学习基石 [](http://beader.me/mlnotebook/section2/vc-dimension-three.html)</li>
  <li><a href="http://www.svms.org/vc-dimension/">vc-dimension in svms</a></li>
  <li><a href="http://www.36dsj.com/archives/21236">机器学习简史</a></li>
</ul>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">100的技术博客</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>100的技术博客</li>
          <li><a href="mailto:zero_based@foxmail.com">zero_based@foxmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/zzbased">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">zzbased</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/zero_based">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">zero_based</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">机器学习，自然语言处理，计算广告学，工作与生活，总结与温习
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
